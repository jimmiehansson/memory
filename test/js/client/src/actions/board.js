'use strict';

/**
 * This notation was generated by templates.
 * // -------------------------------------------------
 * GLOBAL FILE NOTATIONS
 * Project of: memory
 * Filename: board.js by jimmie
 * Created: 2017-05-31 @ 14:54
 * Product of: memory
 * // -------------------------------------------------
 * Make sure this file is part of its proper namespace
 * and project before moving on.
 * // -------------------------------------------------
 * Code-tags conventionally should be used (See below) :
 * TODO - Something that someone need to do.
 * DOING - Self remind for what you are doing.
 * CONSIDER - Reminder to consider a change or addition.
 * BUG - The below section of a code cause a bug.
 * FIXME - The below section of code need to be fixed.
 * HACK - The below section of code is a workaround.
 * XXX - Any notation important enough to consider implementing.
 * CLARIFY - Very incomprehensible section of code below.
 *
 * Created by jimmie on (2017-05-31).
 *
 * Repository link: https://github.com/jimmiehansson/memory.git
 */


/**
 * DOING: Import test associated libraries
 * here to separate from the rest of the code.
 */
const mocha = require('mocha');
const chai = require('chai');
const sinon = require('sinon');


mocha.describe('Testing file: /js/client/src/actions/board.js', () => {


    let testScope = require('../../../../../js/client/src/actions/board');
    let testLibrary = require('../../../../../js/client/src/constants/action-types/board');


    /**
     * DOING: Should test equality for return on function
     * call on getBoardState() fn.
     */
    mocha.describe('Behaviors @action->getBoardState::function', () =>{

        let data = {
            payload : {},
            type : testLibrary.GET_BOARD_STATE
        };

        mocha.describe('Assert normal', () => {
            mocha.it('should return an action object with correct members', ()=> {
                chai.expect(testScope.getBoardState({})).to.deep.equal(data);
            });
            mocha.it('should not return an empty object', ()=> {
                chai.expect(testScope.getBoardState({})).to.not.equal({});
            });
            mocha.it('should have object member @type', ()=> {
                chai.expect(testScope.getBoardState({})).to.deep.property('type');
            });
            mocha.it('should have object member @payload', ()=> {
                chai.expect(testScope.getBoardState({})).to.deep.property('payload');
            });

        });

        mocha.describe('Assert error', () => {
            mocha.it('should not return a string when passed a string', ()=> {
                chai.expect(testScope.getBoardState('')).to.not.deep.equal('string');
            });
            mocha.it('should not return a number when passed a number', ()=> {
                chai.expect(testScope.getBoardState(100)).to.not.deep.equal(100);
            });
            mocha.it('should not return a boolean when passed a boolean', ()=> {
                chai.expect(testScope.getBoardState(true)).to.not.deep.equal(true);
            });
            mocha.it('should not return an array when passed an array', ()=> {
                chai.expect(testScope.getBoardState([])).to.not.deep.equal([]);
            });
        });
    });


    /**
     * DOING: Should test equality for return on function
     * call on boardState() fn.
     */
    mocha.describe('Behaviors @action->boardState::function', () =>{

        let data = {
            payload : {},
            type : testLibrary.GET_BOARD_STATE
        };

        mocha.describe('Assert normal', () => {
            mocha.it('should not return an action object', ()=> {
                chai.expect(testScope.boardState({})).to.not.equal(data);
            });
        });

        mocha.describe('Assert error', () => {
            mocha.it('should not return a string when passed a string', ()=> {
                chai.expect(testScope.boardState('')).to.not.deep.equal('string');
            });
            mocha.it('should not return a number when passed a number', ()=> {
                chai.expect(testScope.boardState(100)).to.not.deep.equal(100);
            });
            mocha.it('should not return a boolean when passed a boolean', ()=> {
                chai.expect(testScope.boardState(true)).to.not.deep.equal(true);
            });
            mocha.it('should not return an array when passed an array', ()=> {
                chai.expect(testScope.boardState([])).to.not.deep.equal([]);
            });

        });
    });


    /**
     * DOING: Should test promise resolve for dispatch with function
     * call on generic() fn.
     */
    mocha.describe('Behaviors @action->dispatch::request', () =>{

        let data = {
            payload : {},
            type : testLibrary.GET_BOARD_STATE
        };

        let method = sinon.stub().returns(Promise.resolve((resolve, reject) => resolve(data)));
        const action = sinon.spy();
        const dispatch = method;

        mocha.describe('Assert callback', () => {

            mocha.it('should return a stub function', () => {
                chai.assert.isFunction(dispatch);
            });
            mocha.it('should dispatch the asynchronous action atleast once', (done) => {
                dispatch(action).then((data) => chai.expect(action.called).to.be.true).catch((err) => err);
                done();
            });
            mocha.it('should dispatch the asynchronous action only once', (done) => {
                dispatch(action).then((data) => chai.expect(action.calledOnce).to.be.true).catch((err) => err);
                done();
            });
            mocha.it('should dispatch the asynchronous action and return data', (done) => {
                dispatch(action).then((data) => chai.expect(action.returned(data)).to.deep.equal(data)).catch((err) => err);
                done();
            });

        });
    });


    /**
     * DOING: Should test equality for return on function
     * call on incrementFlipCount() fn.
     */
    mocha.describe('Behaviors @action->incrementFlipCount::function', () =>{

        let data = {
            type : testLibrary.INCREMENT_FLIPCOUNT_STATE
        };

        mocha.describe('Assert normal', () => {
            mocha.it('should return an action object with correct members', ()=> {
                chai.expect(testScope.incrementFlipCount({})).to.deep.equal(data);
            });
            mocha.it('should not return an empty object', ()=> {
                chai.expect(testScope.incrementFlipCount({})).to.not.equal({});
            });
            mocha.it('should have object member @type', ()=> {
                chai.expect(testScope.incrementFlipCount({})).to.deep.property('type');
            });
            mocha.it('should not have object member @payload', ()=> {
                chai.expect(testScope.incrementFlipCount({})).to.not.deep.property('payload');
            });

        });

        mocha.describe('Assert error', () => {
            mocha.it('should not return a string when passed a string', ()=> {
                chai.expect(testScope.incrementFlipCount('')).to.not.deep.equal('string');
            });
            mocha.it('should not return a number when passed a number', ()=> {
                chai.expect(testScope.incrementFlipCount(100)).to.not.deep.equal(100);
            });
            mocha.it('should not return a boolean when passed a boolean', ()=> {
                chai.expect(testScope.incrementFlipCount(true)).to.not.deep.equal(true);
            });
            mocha.it('should not return an array when passed an array', ()=> {
                chai.expect(testScope.incrementFlipCount([])).to.not.deep.equal([]);
            });
        });
    });


    /**
     * DOING: Should test equality for return on function
     * call on decrementFlipCount() fn.
     */
    mocha.describe('Behaviors @action->decrementFlipCount::function', () =>{

        let data = {
            type : testLibrary.DECREMENT_FLIPCOUNT_STATE
        };

        mocha.describe('Assert normal', () => {
            mocha.it('should return an action object with correct members', ()=> {
                chai.expect(testScope.decrementFlipCount({})).to.deep.equal(data);
            });
            mocha.it('should not return an empty object', ()=> {
                chai.expect(testScope.decrementFlipCount({})).to.not.equal({});
            });
            mocha.it('should have object member @type', ()=> {
                chai.expect(testScope.decrementFlipCount({})).to.deep.property('type');
            });
            mocha.it('should not have object member @payload', ()=> {
                chai.expect(testScope.decrementFlipCount({})).to.not.deep.property('payload');
            });

        });

        mocha.describe('Assert error', () => {
            mocha.it('should not return a string when passed a string', ()=> {
                chai.expect(testScope.decrementFlipCount('')).to.not.deep.equal('string');
            });
            mocha.it('should not return a number when passed a number', ()=> {
                chai.expect(testScope.decrementFlipCount(100)).to.not.deep.equal(100);
            });
            mocha.it('should not return a boolean when passed a boolean', ()=> {
                chai.expect(testScope.decrementFlipCount(true)).to.not.deep.equal(true);
            });
            mocha.it('should not return an array when passed an array', ()=> {
                chai.expect(testScope.decrementFlipCount([])).to.not.deep.equal([]);
            });
        });
    });


    /**
     * DOING: Should test equality for return on function
     * call on incrementActiveGame() fn.
     */
    mocha.describe('Behaviors @action->incrementActiveGame::function', () =>{

        let data = {
            type : testLibrary.INCREMENT_ACTIVEGAME_STATE
        };

        mocha.describe('Assert normal', () => {
            mocha.it('should return an action object with correct members', ()=> {
                chai.expect(testScope.incrementActiveGame({})).to.deep.equal(data);
            });
            mocha.it('should not return an empty object', ()=> {
                chai.expect(testScope.incrementActiveGame({})).to.not.equal({});
            });
            mocha.it('should have object member @type', ()=> {
                chai.expect(testScope.incrementActiveGame({})).to.deep.property('type');
            });
            mocha.it('should not have object member @payload', ()=> {
                chai.expect(testScope.incrementActiveGame({})).to.not.deep.property('payload');
            });

        });

        mocha.describe('Assert error', () => {
            mocha.it('should not return a string when passed a string', ()=> {
                chai.expect(testScope.incrementActiveGame('')).to.not.deep.equal('string');
            });
            mocha.it('should not return a number when passed a number', ()=> {
                chai.expect(testScope.incrementActiveGame(100)).to.not.deep.equal(100);
            });
            mocha.it('should not return a boolean when passed a boolean', ()=> {
                chai.expect(testScope.incrementActiveGame(true)).to.not.deep.equal(true);
            });
            mocha.it('should not return an array when passed an array', ()=> {
                chai.expect(testScope.incrementActiveGame([])).to.not.deep.equal([]);
            });
        });
    });


    /**
     * DOING: Should test equality for return on function
     * call on incrementScoreCount() fn.
     */
    mocha.describe('Behaviors @action->incrementScoreCount::function', () =>{

        let data = {
            type : testLibrary.INCREMENT_SCORECOUNT_STATE
        };

        mocha.describe('Assert normal', () => {
            mocha.it('should return an action object with correct members', ()=> {
                chai.expect(testScope.incrementScoreCount({})).to.deep.equal(data);
            });
            mocha.it('should not return an empty object', ()=> {
                chai.expect(testScope.incrementScoreCount({})).to.not.equal({});
            });
            mocha.it('should have object member @type', ()=> {
                chai.expect(testScope.incrementScoreCount({})).to.deep.property('type');
            });
            mocha.it('should not have object member @payload', ()=> {
                chai.expect(testScope.incrementScoreCount({})).to.not.deep.property('payload');
            });

        });

        mocha.describe('Assert error', () => {
            mocha.it('should not return a string when passed a string', ()=> {
                chai.expect(testScope.incrementScoreCount('')).to.not.deep.equal('string');
            });
            mocha.it('should not return a number when passed a number', ()=> {
                chai.expect(testScope.incrementScoreCount(100)).to.not.deep.equal(100);
            });
            mocha.it('should not return a boolean when passed a boolean', ()=> {
                chai.expect(testScope.incrementScoreCount(true)).to.not.deep.equal(true);
            });
            mocha.it('should not return an array when passed an array', ()=> {
                chai.expect(testScope.incrementScoreCount([])).to.not.deep.equal([]);
            });
        });
    });
});




